<!DOCTYPE html>
<html lang="zh-CN" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>小先生乘法表 (最终融合版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- 核心布局与背景 --- */
        body {
            background-color: #eaf0f7; /* 更柔和的基础背景色 */
            position: relative;
            overflow: hidden;
        }

        /* --- 全新液态玻璃背景 (Apple VisionOS 风格) --- */
        #liquid-background-container {
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            z-index: -2;
            transition: transform 0.2s ease-out; /* 用于指针交互的平滑过渡 */
        }

        .liquid-blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px); /* 关键：高斯模糊创造融合效果 */
            opacity: 0.6;
            animation: move-blob 30s infinite alternate ease-in-out;
        }

        /* 定义几个不同颜色、大小和位置的团块 */
        .liquid-blob:nth-child(1) {
            background: #87CEEB; /* 天蓝色 */
            width: 50%; height: 50%;
            top: 10%; left: 10%;
            animation-duration: 32s;
        }
        .liquid-blob:nth-child(2) {
            background: #D8BFD8; /* 蓟色 (淡紫色) */
            width: 40%; height: 40%;
            top: 50%; left: 60%;
            animation-duration: 28s;
            animation-delay: -8s;
        }
        .liquid-blob:nth-child(3) {
            background: #98FB98; /* 苍绿 */
            width: 45%; height: 45%;
            top: 60%; left: 20%;
            animation-duration: 35s;
            animation-delay: -15s;
        }
        .liquid-blob:nth-child(4) {
            background: #FFC0CB; /* 粉色 */
            width: 35%; height: 35%;
            top: 20%; left: 70%;
            animation-duration: 25s;
            animation-delay: -5s;
        }

        /* 更有机、更复杂的移动动画 - 移动端减少关键帧数量 */
        @keyframes move-blob {
            0% { transform: translate(0, 0) rotate(0deg) scale(1); }
            50% { transform: translate(-5vw, 5vh) rotate(180deg) scale(0.95); }
            100% { transform: translate(0, 0) rotate(360deg) scale(1); }
        }
        
        /* 桌面端使用更复杂的动画 */
        @media (min-width: 768px) {
            @keyframes move-blob {
                0% { transform: translate(0, 0) rotate(0deg) scale(1); }
                25% { transform: translate(15vw, -20vh) rotate(90deg) scale(1.1); }
                50% { transform: translate(-10vw, 10vh) rotate(180deg) scale(0.9); }
                75% { transform: translate(20vw, 15vh) rotate(270deg) scale(1.2); }
                100% { transform: translate(0, 0) rotate(360deg) scale(1); }
            }
        }

        /* --- 指针响应式光泽层 --- */
        #pointer-gloss {
            position: fixed;
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0) 60%);
            border-radius: 50%;
            z-index: -1;
            pointer-events: none;
            transition: transform 0.1s linear;
            transform: translate(-50%, -50%); /* 中心点对齐 */
        }
        
        /* --- 优化的毛玻璃效果 --- */
        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px); /* 增强模糊效果 */
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.25); /* 增加内发光，模拟厚度 */
        }

        .glass-cell {
            position: relative;
            /* 基础背景色，会被JS的内联样式覆盖 */
            background: rgba(255, 255, 255, 0.1); 
            backdrop-filter: blur(8px);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.08),
                inset 0 1px 0px rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            border: 3px solid rgba(255, 255, 255, 0.85);
        }
        
        .glass-cell-content {
            position: relative;
            z-index: 1;
            font-weight: 600; 
            color: rgba(30, 41, 59, 0.9);
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.6);
            letter-spacing: -0.5px;
        }

        .glass-cell.highlighted {
            background-color: rgba(255, 255, 255, 0.3) !important; /* 使用!important确保覆盖内联样式 */
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.1),
                inset 0 0 0 1.5px rgba(255, 255, 255, 0.4);
            transform: translateY(-2px) scale(1.02);
            border-color: rgba(255, 212, 100, 0.7);
        }
        
        .glass-cell.active-cell {
            background-color: rgba(255, 255, 255, 0.45) !important; /* 使用!important确保覆盖内联样式 */
            box-shadow: 
                0 10px 30px rgba(255, 180, 0, 0.25),
                inset 0 0 0 2px rgba(255, 255, 255, 0.6);
            transform: translateY(-4px) scale(1.05);
            z-index: 30 !important;
            border: 2px solid rgba(255, 212, 100, 0.9);
        }
        
        /* 顶部显示区域的毛玻璃效果 */
        .display-glass {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(16px);
            border-radius: 20px;
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.1),
                inset 0 1px 1px rgba(255, 255, 255, 0.3);
            padding: 1.25rem;
            border: 1px solid rgba(255, 255, 255, 0.25);
        }

        /* --- 其他动画和辅助样式 (保持不变) --- */
        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-15px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in-down { animation: fadeInDown 0.5s ease-out forwards; }
        @keyframes popIn { from { transform: scale(0.3); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .modal-item-animate { transform: scale(0.3); opacity: 0; animation: popIn 0.3s ease-out forwards; }
        @keyframes typing { from { width: 0; } to { width: 100%; } }
        .typing-effect { display: inline-block; overflow: hidden; white-space: nowrap; animation: typing 0.8s steps(30, end) forwards; }
        
        /* 针对移动设备优化样式 */
        @media (max-width: 767px) {
            /* 移动设备上降低毛玻璃效果强度 */
            .glass-effect {
                backdrop-filter: blur(5px); /* 降低模糊程度 */
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
            }
            
            /* 简化显示区域的效果 */
            .display-glass {
                backdrop-filter: blur(8px);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            }
            
            /* 减少阴影和模糊效果 */
            .glass-cell {
                backdrop-filter: none;
                border-width: 1px;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            }
            
            /* 减少过渡动画持续时间 */
            .touch-feedback::after {
                transition: transform 0.15s, opacity 0.15s;
            }
            
            /* 减少模态框的模糊效果 */
            #modal-overlay {
                backdrop-filter: blur(3px);
            }
        }
        
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after { animation: none !important; transition: none !important; }
        }

        .touch-feedback { position: relative; overflow: hidden; }
        .touch-feedback::after { content: ''; display: block; position: absolute; width: 100%; height: 100%; top: 0; left: 0; background: rgba(255, 255, 255, 0.3); opacity: 0; transform: scale(0); border-radius: inherit; transition: transform 0.3s, opacity 0.3s; pointer-events: none; }
        .touch-feedback.active::after { transform: scale(1); opacity: 1; transition: 0s; }

        /* 移动设备专用样式 */
        @media (max-width: 767px) {
            .glass-cell {
                border-radius: 8px;
                border: 2px solid rgba(255, 255, 255, 0.7);
            }
            
            .glass-cell-content {
                font-size: 0.875rem; /* 更小的字体适应小屏幕 */
            }
            
            #pointer-gloss {
                width: 300px;
                height: 300px;
            }
            
            /* 调整顶部显示区域的间距 */
            .display-glass {
                padding: 1rem;
            }
            
            /* 简化动画效果 */
            @keyframes move-blob {
                0% { transform: translate(0, 0) rotate(0deg) scale(1); }
                100% { transform: translate(0, 0) rotate(360deg) scale(1); }
            }
        }
    </style>
</head>
<body class="h-full flex flex-col items-center justify-center p-4 font-sans select-none">
    
    <!-- 全新动态液体背景 -->
    <div id="liquid-background-container">
        <div class="liquid-blob"></div>
        <div class="liquid-blob"></div>
        <div class="liquid-blob"></div>
        <div class="liquid-blob"></div>
    </div>
    <!-- 指针光泽效果 -->
    <div id="pointer-gloss"></div>
      <!-- 页面内容 -->
    <div id="display-area" class="display-glass h-28 sm:h-32 flex flex-col items-center justify-center text-center mb-4 sm:mb-6 w-full max-w-lg z-10">
        <h1 id="chinese-phrase" class="text-3xl sm:text-4xl md:text-5xl font-bold text-slate-800"></h1>
        <div id="equation-container" class="overflow-hidden mt-1 sm:mt-2">
            <p id="numeric-equation" class="text-lg sm:text-xl text-slate-700"></p>
        </div>
    </div>    <div id="grid-container" class="w-full max-w-lg mx-auto aspect-square grid grid-cols-9 gap-1 sm:gap-1.5 md:gap-2 p-0.5 sm:p-1 z-10">
        <!-- JS动态生成格子 -->
    </div><!-- 新增页脚部分 -->
    <footer class="glass-effect mt-6 sm:mt-8 py-2 sm:py-3 px-4 sm:px-6 rounded-full text-center w-full max-w-lg mx-auto z-10 text-slate-700">
        <div class="flex flex-col md:flex-row items-center justify-between gap-1 sm:gap-2">
            <p class="text-xs sm:text-sm">© <span id="current-year"></span> 小先生乘法表</p>
            <div class="flex items-center space-x-2 sm:space-x-3">
                <span class="text-xs hidden sm:inline">使用互动方式学习乘法</span>
                <span class="text-xs inline sm:hidden">互动学习</span>
                <div class="h-3 sm:h-4 w-px bg-slate-300/50"></div>
                <span class="text-xs">长按可视觉化数字</span>
            </div>
        </div>
    </footer>

    <div id="toast" class="fixed bottom-5 bg-gradient-to-r from-amber-400/95 to-amber-500/95 backdrop-blur-sm text-white py-2 px-6 rounded-full shadow-lg text-sm opacity-0 transition-opacity duration-300 z-50">
        提示信息
    </div>

    <div id="modal-overlay" class="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center p-4 hidden z-50" onclick="this.classList.add('hidden')">
        <div id="modal-content" class="glass-effect bg-white/20 p-6 rounded-2xl shadow-2xl" onclick="event.stopPropagation()">
            <!-- JS动态生成阵列 -->
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM 元素 ---
            const gridContainer = document.getElementById('grid-container');
            const chinesePhraseEl = document.getElementById('chinese-phrase');
            const numericEquationEl = document.getElementById('numeric-equation');
            const toastEl = document.getElementById('toast');
            const modalOverlay = document.getElementById('modal-overlay');
            const modalContent = document.getElementById('modal-content');
            const liquidBackground = document.getElementById('liquid-background-container');
            const pointerGloss = document.getElementById('pointer-gloss');

            // --- 状态变量和常量 ---
            let longPressTimer = null;
            const LONG_PRESS_DURATION = 600;
            const speechCache = {};
            let isSpeechInitialized = false;
            let hasUserInteracted = false;
            let isAnimating = false;
            
            // 检测移动设备 - 新增用于性能优化
            const isMobileDevice = () => {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
            };
            
            // 设置低性能模式 - 新增
            const setLowPerformanceMode = () => {
                // 减少或禁用背景动画
                document.querySelectorAll('.liquid-blob').forEach(blob => {
                    blob.style.animationPlayState = 'paused';
                    blob.style.filter = 'blur(40px)'; // 降低模糊程度
                });
                
                // 减少毛玻璃效果
                document.querySelectorAll('.glass-cell').forEach(cell => {
                    cell.style.backdropFilter = 'none'; // 移除单元格模糊效果
                    cell.style.boxShadow = '0 2px 6px rgba(0, 0, 0, 0.05)'; // 简化阴影
                });
                
                // 移除指针光泽
                if (pointerGloss) {
                    pointerGloss.style.display = 'none';
                }
                
                // 简化其他效果
                document.querySelector('.display-glass').style.backdropFilter = 'blur(8px)'; // 降低模糊度
            };
            
            // --- 核心功能函数 ---

            // 生成 9x9 网格，并恢复原始的多彩背景功能
            const initGrid = () => {
                const fragment = document.createDocumentFragment();
                const isMobile = isMobileDevice();
                
                for (let row = 1; row <= 9; row++) {
                    for (let col = 1; col <= 9; col++) {
                        const cell = document.createElement('div');
                        const cellContent = document.createElement('div');
                        const product = row * col;
                        // 更小的手机屏幕使用更小的字体
                        const fontSize = product >= 10 ? 
                            (product >= 70 ? 'text-sm sm:text-lg md:text-2xl' : 'text-base sm:text-xl md:text-2xl') : 
                            'text-lg sm:text-2xl md:text-3xl';
                        
                        // 移动端使用更简化的样式类
                        cell.className = isMobile ? 
                            'grid-cell flex items-center justify-center aspect-square cursor-pointer' :
                            'grid-cell glass-cell touch-feedback flex items-center justify-center aspect-square cursor-pointer transition-all duration-300 hover:scale-105';
                        
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // 设置背景颜色（移动设备使用更简单的颜色）
                        cell.style.backgroundColor = isMobile ? 
                            `hsla(${(row + col) * 20}, 60%, 80%, 0.3)` :
                            `hsla(${(row + col) * 20}, 60%, 80%, 0.15)`;
                        
                        // 移动设备上添加简单的边框而非复杂效果
                        if (isMobile) {
                            cell.style.border = '1px solid rgba(255, 255, 255, 0.5)';
                            cell.style.borderRadius = '8px';
                        }
                        
                        cellContent.className = `${isMobile ? '' : 'glass-cell-content'} ${fontSize}`;
                        cellContent.style.fontWeight = '600';
                        cellContent.style.color = 'rgba(30, 41, 59, 0.9)';
                        cellContent.textContent = product;
                        
                        cell.appendChild(cellContent);
                        fragment.appendChild(cell);
                    }
                }
                gridContainer.appendChild(fragment);
            };

            // 全新：指针交互效果
            const setupPointerInteraction = () => {
                // 移动设备上不启用指针交互效果
                if (isMobileDevice()) {
                    return;
                }
                
                let pointerX = 0, pointerY = 0;
                window.addEventListener('mousemove', (e) => {
                    pointerGloss.style.transform = `translate(calc(${e.clientX}px - 50%), calc(${e.clientY}px - 50%))`;
                    pointerX = (e.clientX / window.innerWidth) - 0.5;
                    pointerY = (e.clientY / window.innerHeight) - 0.5;
                });
                
                // 使用节流函数来减少背景动画更新频率
                let lastTime = 0;
                const animateParallax = (timestamp) => {
                    if (!lastTime || timestamp - lastTime >= 50) { // 限制为每秒20帧
                        lastTime = timestamp;
                        const moveX = pointerX * -30;
                        const moveY = pointerY * -30;
                        liquidBackground.style.transform = `translate(${moveX}px, ${moveY}px)`;
                    }
                    requestAnimationFrame(animateParallax);
                };
                
                if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                    requestAnimationFrame(animateParallax);
                }
            };
            
            // --- 粘贴所有其他未变的JS函数 ---
            const numToCN = (num) => {
                const cnNums = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'];
                const cnUnits = ['', '十', '百'];
                if (num <= 10) return num === 10 ? cnUnits[1] : cnNums[num];
                const digits = String(num).split('');
                if (num < 20) return `${cnUnits[1]}${cnNums[digits[1]]}`;
                if (num % 10 === 0) return `${cnNums[digits[0]]}${cnUnits[1]}`;
                return `${cnNums[digits[0]]}${cnUnits[1]}${cnNums[digits[1]]}`;
            };
            const generatePhrase = (n1, n2) => {
                if (n1 === 1 && n2 === 1) return '一一得一';
                const product = n1 * n2;
                return `${numToCN(n1)}${numToCN(n2)}${numToCN(product)}`;
            };
            const initSpeech = () => { if (!window.speechSynthesis || isSpeechInitialized) return false; try { const warmUp = new SpeechSynthesisUtterance(''); speechSynthesis.speak(warmUp); isSpeechInitialized = true; return true; } catch (e) { console.warn('语音合成初始化失败:', e); return false; } };
            const cacheSpeech = (row, col) => { if (!window.speechSynthesis || !isSpeechInitialized) return; for (let i = Math.max(1, row - 1); i <= Math.min(9, row + 1); i++) { for (let j = Math.max(1, col - 1); j <= Math.min(9, col + 1); j++) { const text = generatePhrase(i, j); if (!speechCache[text]) { const utterance = new SpeechSynthesisUtterance(text); utterance.lang = 'zh-CN'; utterance.rate = 1.1; speechCache[text] = utterance; } } } };
            const speak = (text) => { if (!window.speechSynthesis) return; if (!isSpeechInitialized && !initSpeech()) return; let utterance = speechCache[text]; if (!utterance) { utterance = new SpeechSynthesisUtterance(text); utterance.lang = 'zh-CN'; utterance.rate = 1.1; speechCache[text] = utterance; } speechSynthesis.cancel(); speechSynthesis.speak(utterance); };
            const updateDisplay = (text, equation) => { if (isAnimating) return; isAnimating = true; chinesePhraseEl.textContent = text; numericEquationEl.className = ''; numericEquationEl.style.width = '0'; numericEquationEl.textContent = equation; requestAnimationFrame(() => { numericEquationEl.className = 'typing-effect text-xl text-slate-700'; setTimeout(() => { isAnimating = false; }, 800); }); };
            const showToast = (message) => { toastEl.textContent = message; toastEl.classList.remove('opacity-0'); clearTimeout(toastEl.timer); toastEl.timer = setTimeout(() => toastEl.classList.add('opacity-0'), 2000); };
            const resetHighlights = () => { gridContainer.querySelectorAll('.grid-cell').forEach(cell => { cell.classList.remove('highlighted', 'active-cell', 'z-20'); }); };
            const addTouchFeedback = (element) => { element.classList.add('active'); setTimeout(() => { element.classList.remove('active'); }, 150); };
            const handleClick = (row, col, target) => { if (!hasUserInteracted) { hasUserInteracted = true; initSpeech(); } addTouchFeedback(target); resetHighlights(); const product = row * col; for (let r = 1; r <= row; r++) { for (let c = 1; c <= col; c++) { const currentCell = gridContainer.querySelector(`[data-row='${r}'][data-col='${c}']`); if (currentCell) { currentCell.classList.add('highlighted'); currentCell.style.zIndex = 10; } } } target.classList.add('active-cell'); const phrase = generatePhrase(row, col); updateDisplay(phrase, `${row} × ${col} = ${product}`); speak(phrase); cacheSpeech(row, col); };
            const handleLongPress = (row, col) => { 
                modalContent.innerHTML = ''; 
                const product = row * col; 
                const fragment = document.createDocumentFragment(); 
                
                // 移动设备上使用更小的尺寸和更简单的视觉效果
                const isMobile = isMobileDevice();
                const maxItems = isMobile && product > 50 ? 50 : product; // 移动设备上限制项目数
                
                const itemSize = Math.max(
                    isMobile ? 10 : 16, 
                    Math.min(isMobile ? 30 : 40, 
                    Math.floor(320 / Math.max(col, Math.ceil(product/col))))); 
                
                const optimalCols = col > 15 ? Math.ceil(Math.sqrt(product)) : col; 
                modalContent.style.gridTemplateColumns = `repeat(${optimalCols}, 1fr)`; 
                modalContent.classList.add('grid', 'gap-2'); 
                
                // 优化渲染
                const batchSize = 10; // 批量处理的元素数
                let currentBatch = 0;
                
                const createBatch = (startIndex) => {
                    const endIndex = Math.min(startIndex + batchSize, maxItems);
                    const batchFragment = document.createDocumentFragment();
                    
                    for(let i = startIndex; i < endIndex; i++) { 
                        const item = document.createElement('div'); 
                        // 移动设备上简化类名和效果
                        item.className = isMobile ? 
                            'rounded-lg' : 
                            'modal-item-animate glass-effect rounded-lg'; 
                        
                        item.style.width = `${itemSize}px`; 
                        item.style.height = `${itemSize}px`; 
                        item.style.backgroundColor = `hsla(${(row + col) * 20}, 80%, 70%, ${isMobile ? 0.5 : 0.4})`; 
                        
                        // 只在非移动设备上使用动画延迟
                        if (!isMobile) {
                            item.style.animationDelay = `${Math.min(i * 0.02, 1)}s`; 
                        }
                        
                        batchFragment.appendChild(item); 
                    }
                    
                    modalContent.appendChild(batchFragment); 
                    
                    // 如果还有更多元素需要处理，安排下一批
                    if (endIndex < maxItems) {
                        setTimeout(() => createBatch(endIndex), 16); // 大约一帧的时间
                    }
                };
                
                // 开始处理第一批
                requestAnimationFrame(() => {
                    createBatch(0);
                    modalOverlay.classList.remove('hidden');
                }); 
            };
            const setupEvents = () => { gridContainer.addEventListener('mousedown', (e) => { const cell = e.target.closest('.grid-cell'); if (!cell) return; const { row, col } = cell.dataset; longPressTimer = setTimeout(() => { handleLongPress(Number(row), Number(col)); longPressTimer = null; }, LONG_PRESS_DURATION); }); const clearLongPress = () => { if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; } }; gridContainer.addEventListener('mouseup', (e) => { if (longPressTimer) { clearTimeout(longPressTimer); const cell = e.target.closest('.grid-cell'); if (cell) { const { row, col } = cell.dataset; handleClick(Number(row), Number(col), cell); } } }); let touchStartX, touchStartY; gridContainer.addEventListener('touchstart', (e) => { const cell = e.target.closest('.grid-cell'); if (!cell) return; touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; e.preventDefault(); const { row, col } = cell.dataset; longPressTimer = setTimeout(() => { handleLongPress(Number(row), Number(col)); longPressTimer = null; }, LONG_PRESS_DURATION); }, { passive: false }); gridContainer.addEventListener('touchmove', (e) => { if (longPressTimer) { const distance = Math.sqrt(Math.pow(e.touches[0].clientX - touchStartX, 2) + Math.pow(e.touches[0].clientY - touchStartY, 2)); if (distance > 10) { clearTimeout(longPressTimer); longPressTimer = null; } } }, { passive: true }); gridContainer.addEventListener('touchend', (e) => { if (longPressTimer) { clearTimeout(longPressTimer); const cell = e.target.closest('.grid-cell'); if (cell) { const { row, col } = cell.dataset; handleClick(Number(row), Number(col), cell); } } }); gridContainer.addEventListener('mouseleave', clearLongPress); gridContainer.addEventListener('touchcancel', clearLongPress); document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden') { if (window.speechSynthesis) { speechSynthesis.cancel(); } clearLongPress(); if (toastEl.timer) { clearTimeout(toastEl.timer); } } }); window.addEventListener('beforeunload', () => { if (window.speechSynthesis) { speechSynthesis.cancel(); } }); };

            // --- 执行初始化 ---
            initGrid();
            setupEvents();
            
            // 根据设备性能决定是否启用高级效果
            if (isMobileDevice()) {
                setLowPerformanceMode();
            } else {
                setupPointerInteraction();
            }
            
            updateDisplay('小先生乘法表', '请点击任意方块学习口诀');
            
            // 设置页脚年份
            document.getElementById('current-year').textContent = new Date().getFullYear();
        });
    </script>
</body>
</html>
